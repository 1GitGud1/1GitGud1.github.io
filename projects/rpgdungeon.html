<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- stylesheet -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">
        <link rel="stylesheet" href="project_css.css"/>
        <!-- script -->
        <script src="project_js.js" defer></script>
    </head>
    <body style="
    background-image: 
        linear-gradient(to bottom, rgba(255, 255, 255, 0) 10%, #040F16 100%), 
        url('../images/goblin\ thumbnail1.png');
    background-size: cover, cover;
    background-position: center, center;
    background-repeat: no-repeat, no-repeat;">
        <header>
            <nav class="nav full-nav">
                <div class="contents">
                    <a href="https://isaisadev.com#about">About</a>
                    <a href="https://isaisadev.com#projects">Projects</a>
                    <a href="https://isaisadev.com#contact">Contact</a>
                    <a href="/images/Isa-Isaev Resume.pdf" target="_blank">Resume</a>
                </div>
                <div class="social-media-icons">
                    <a href="https://github.com/1GitGud1"><i class="bi bi-github"></i></a>
                    <a href="https://linkedin.com/in/isa-isaev-137678326"><i class="bi bi-linkedin"></i></a>
                    <a href="https://www.youtube.com/channel/UC2TLnYm7FyWBZfQmi0H9M9w"><i class="bi bi-youtube"></i></a>
                    <a href="https://www.instagram.com/isaisaev011?igsh=bHRuaDIwZDM3ZTI0"><i class="bi bi-instagram"></i></a>
                </div>
            </nav>
        </header>
        <div class="column">
            <div class="intro">
                <h1 style="font-size:500%;">RPG Dungeon</h1>
                <div style="margin:auto;">
                    <pre style="line-height: 200%;">
<b>Project Type</b>      Personal
<b>Software Used</b>     Unity
<b>Languages Used</b>    C#, HLSL
<b>Primary Role(s)</b>   Gameplay Programmer
                    </pre>
                </div>
                <p>RPG Dungeon is my passion project for my ideal video game. It's an RPG platformer inspired by games like Vagante, DnD, and more. So far, it features Procedurally Generated Levels, 
                    Inventory and Items System, Enemy AI state Machines with Platformer A* Pathfinding, Custom Pixel Animations with many more systems and features planned to come at an unknown date, 
                    but their arrival is certain.
                </p>
            </div>
            <div class="content">
                <h1>Introduction</h1>
                <p>It's the first big project I started with the intent of learning Unity systems and sharpening my programming skills, though actually finishing it one day 
                    would be a pretty pleasant bonus. It's a piece of art I keep coming back to and shaping in my free time. The core concept is a fantasy D&D-inspired experience in a procedurally 
                    generated dungeon with combat heavily influenced by your character's stats, abilities and environment - allowing for wide variety of playstyles.
                </p>
                <h1>Finite State Machines (for AI logic)</h1>
                <p>All NPC types in the game are driven by their own Finite State Machine (FSM), which share the same overall structure with their own states but support NPC-specific variables and 
                    functions within the State Machine Manager. For example, the goblin FSM includes custom stats like max health, knockback for attacks, as well as goblin-specific  
                    functions such as their pathfinding algorithm and arrow-shooting logic. </p>
                <pre><code>
public class GoblinStateManager : MonoBehaviour, IDamageable
{
    GoblinBaseState currentState;
    public GoblinIdleState idleState = new GoblinIdleState();
    public GoblinPursuingState pursuingState = new GoblinPursuingState();
    public GoblinShootingState shootingState = new GoblinShootingState();
    public GoblinSearchingState searchingState = new GoblinSearchingState();
    public GoblinDeadState deadState = new GoblinDeadState();

    public Rigidbody2D m_Rigidbody2D;
    public Animator animator;
    public Transform target;
    public Vector3 targetLastSeen;
    public Transform bow;
    public GameObject arrow;
    public LayerMask groundLayerMask;
    public KnockbackScript knockbackScript;

    public bool m_FacingRight = false;
    // The variable is calculated and set during the GoblinShootingState
    public float bowAngle;

    // Timer that starts after character jumps, used for ground checks
    public float jumpCooldown;

    // Character stats
    public int maxHealth = 20;
    int currentHealth;
    private float knockbackStr = 80;

    // Pathfinding variables
    public Node[] path;
    int targetIndex;

    void Start()
    {
        // Gets the reference for bow GameObject
        bow = transform.GetChild(0).transform;

        currentState = idleState;
        currentState.EnterState(this);

        currentHealth = maxHealth;
        path = new Node[0];
    }

    // Update is called once per frame
    void Update()
    {
        currentState.UpdateState(this);
    }

    void FixedUpdate()
    {
        currentState.FixedUpdateState(this);
    }

    public void SwitchState(GoblinBaseState state)
    {
        currentState = state;
        state.EnterState(this);
    }

    public void Flip()
	{
		// Switch the way the player is labelled as facing.
		m_FacingRight = !m_FacingRight;

		// Multiply the player's x local scale by -1, to change facing direction.
		Vector3 theScale = transform.localScale;
		theScale.x *= -1;
		transform.localScale = theScale;
	}

    // Spins the character sprite to face their target. Used when attacking.
    public void FaceTarget()
    {
        if (transform.position.x &lt; target.position.x)
        {
            Vector3 theScale = transform.localScale;
            theScale.x = -1;
            transform.localScale = theScale;
            m_FacingRight = false;
        }
        else
        {
            Vector3 theScale = transform.localScale;
            theScale.x = 1;
            transform.localScale = theScale;
            m_FacingRight = true;
        }
    }

    // Spawns an arrow with force added at an angle the bow is positioned.
    public void ShootArrow()
    {
        if (m_FacingRight)
        {
            GameObject projectile = Instantiate(arrow, transform.position, Quaternion.identity);
            projectile.GetComponent<Rigidbody2D>().AddForce(1f * GetVectorFromAngle(bowAngle + 180), ForceMode2D.Impulse);
            animator.SetBool("Shooting", false);
            SwitchState(pursuingState);
        }
        else
        {
            GameObject projectile = Instantiate(arrow, transform.position, Quaternion.identity);
            projectile.GetComponent<Rigidbody2D>().AddForce(1f * GetVectorFromAngle(bowAngle), ForceMode2D.Impulse);
            animator.SetBool("Shooting", false);
            SwitchState(pursuingState);
        }
    }

    private static Vector3 GetVectorFromAngle(float angle) {
        float angleRad = angle * (Mathf.PI/180f);
        return new Vector3(Mathf.Cos(angleRad), Mathf.Sin(angleRad));
    }

    public void TakeDamage(int DMG, Vector3 point)
    {
        currentHealth -= DMG;
        Debug.Log("Character dealt " + DMG + " damage");
        
        //Play hurt animation
        
        targetLastSeen = target.position;

        if(currentHealth &lt;= 0)
        {
            SwitchState(deadState);
        } 
        else if (currentState == idleState) 
        {
            SwitchState(pursuingState);
        }

        
        knockbackScript.knockback(point.x, knockbackStr);
    }


    public bool GroundCheck()
    {
        // The GroundCheck has a cooldown so that the raycast is not performed immediately after jump function is called, otherwise jump function is called multiple times in a single instance of a jump
        if (jumpCooldown >= 0.3f)
        {
            RaycastHit2D groundCheck = Physics2D.Raycast(transform.position, Vector2.down, 0.15f, groundLayerMask);
            if (groundCheck.collider != null)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }
    }

    public void OnPathFound(Node[] newPath, bool pathSuccessful) 
    {
        if (pathSuccessful) {
            path = newPath;

            StopCoroutine("FollowPath");
            StartCoroutine("FollowPath");
        } 
        
    }

    public IEnumerator FollowPath()
    {
        animator.SetFloat("Speed", 1);
        Vector3 currentWaypoint = path[0].worldPosition;
        targetIndex = 0;

        while (true) {
            if (Vector2.Distance(transform.position,currentWaypoint) &lt; 0.1f) {
                targetIndex++;
                if (targetIndex >= path.Length) {
                    path = new Node[0];

                    SwitchState(idleState);

                    yield break;
                }
                currentWaypoint = path[targetIndex].worldPosition;
            }

            // Movement towards nodes logic
            //Debug.Log(path.Length + " is the length of array");
            Debug.Log(targetIndex + " is the index searched");
            if (path[targetIndex].jumpToNode && GroundCheck()){
                jumpCooldown = 0;
                m_Rigidbody2D.velocity = new Vector2(pursuingState.horizontalMove*Time.deltaTime, 0);
                yield return new WaitForSeconds(0.1f);
                m_Rigidbody2D.AddForce(new Vector2(0, 3.25f), ForceMode2D.Impulse);
            }
            if(transform.position.x &lt; currentWaypoint.x){
                pursuingState.horizontalMove = 50;
            } 
            else if (Mathf.Abs(transform.position.x - currentWaypoint.x) &lt; 0.02f) {
                m_Rigidbody2D.velocity = new Vector2(0, m_Rigidbody2D.velocity.y);
            }
            else {
                pursuingState.horizontalMove = -50;
            }

            yield return null;
        }
    }
}
                </code></pre>
            </div>
        </div>
    </body>
</html>